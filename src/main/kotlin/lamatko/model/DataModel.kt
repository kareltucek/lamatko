package lamatko

enum class Order(
    val littleEndian: Boolean = false,
    val bigEndian: Boolean = false,
    val others: Boolean = false,
    val inheritWhenAplicable: Boolean = false,
) {
    LittleEndian(littleEndian = true),
    BigEndian(bigEndian = true),
    EitherEndian(bigEndian = true, littleEndian = true),
    EitherEndianInherited(bigEndian = true, littleEndian = true, inheritWhenAplicable = true),
    UnknownInherited(others = true, inheritWhenAplicable = true),
    Unknown(others = true);
}

/**
 * Stores encoding of one digit.
 */
data class Digit (
    val valueOrder: Order,
    val values: List<Char>,
)

/**
 * Target alphabets.
 */
enum class Alphabet(val chars: List<String>, val isObscure: Boolean = false) {
    Standard(arrayListOf( "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z" )),
    QLess(arrayListOf( "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "r", "s", "t", "u", "v", "w", "x", "y", "z" )),
    WLess(arrayListOf( "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "x", "y", "z" )),
    ChAdded( arrayListOf("a", "b", "c", "d", "e", "f", "g", "h", "ch", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z" )),
    WLessChAdded( isObscure = true, chars = arrayListOf("a", "b", "c", "d", "e", "f", "g", "h", "ch", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "x", "y", "z" )),
    BrailleCz( isObscure = true, chars = BrailleGenerator.getBraille()),
    Braille2Cz( isObscure = true, chars = BrailleGenerator.getBraille2() ),
    Braille3Cz( isObscure = true, chars = BrailleGenerator.getBraille3() ),
    Semaphore1( isObscure = true, chars = SemaphoreGenerator.getSemaphore(1, 8)),
    Semaphore2( isObscure = true, chars = SemaphoreGenerator.getSemaphore(0, 9)),
}

/**
 * We assume that the cipher corresponds to some number-like coding, and hereby descibe what is known about this coding.
 * Later, this information will be used to produce decoder candidates.
 *
 * All inputs and intermediate data are stored as little-endian.
 */
data class Problem (
    val digitOrder: Order,
    val digits: List<Digit>,
    val alphabets: List<Alphabet>,
    val offsets: List<Int>,
    val code: List<CodeUnit>,
)

/**
 * Represents group of characters which encode one letter.
 */
typealias CodeUnit = List<Char>

/**
 * Decoder candidate, fully describing exactly one decoding mechanism. These are generated by combinatorial
 * expansion of the `Problem` class.
 */
data class Decoder(
    val priority: Int,
    val digitTable: List<Map<Char, Int>>,
    val code: List<CodeUnit>,
    val startOffset: Int,
    val alphabet: Alphabet,
) {
    fun describe(): String {
        val alphabet = alphabet.name
        val table = digitTable.reversed().map {
            val sortedDigits = it.toList()
                .sortedBy { it.second }
            val digits = sortedDigits
                .map { it.first }
                .filter { it != ' ' }
                .joinToString("")
            val magnitude = {
                fun <T, R> Pair<T?, T?>.flatMap(f: (T, T) -> R?): R? {
                    return this.first?.let { a -> this.second?.let { b -> f(a, b) }}
                }
                fun diff (a: Int, b: Int): Int? = (sortedDigits.getOrNull(a)?.second to sortedDigits.getOrNull(b)?.second)
                        .flatMap { a, b -> b - a }

                if (diff(0, 1) == diff(1, 2) || sortedDigits.size < 3) {
                    sortedDigits.getOrNull(1)?.second
                        ?.let { "($it)" }
                } else {
                    val base = diff(0, 1)
                    val quotient = (diff(0,1) to diff(1, 2)).flatMap { a,b -> b/a }

                    (base to quotient).flatMap { b,q -> "($b*$q)" }
                }
            }

            digits + magnitude()
        }.joinToString(" ")

        return "$table - $alphabet"
    }
}

/**
 * Single result candidate instance.
 */
data class Result(
    val rating: Double,
    val result: String,
    val decoder: Decoder,
) {
    fun describe(): String {
        val rating = rating.toString().let { it.substring(0, 8.coerceAtMost(it.length)) }
        val decoder = decoder.describe()

        return listOf(result, rating, decoder).joinToString (" - ")
    }
}

/**
 * In order to identify solution candidates, we compare frequency of characters and character pairs of a decoded text
 * with a precomputed probability profile.
 */
data class BackgroundProfile(
    val probabilities: List<FrequencyMap>,
) {
    data class FrequencyMap(
        val map: Map<String, Double>,
        val defaultRating: Double,
        val degree: Int,
    )

    companion object {
        val default = ProfileGenerator.generateProfileFromString(
            ProfileGenerator.SeedTexts.czech + ProfileGenerator.SeedTexts.english,
            degrees = listOf(3)
        )
    }
}