package lamatko

enum class Order(
    val littleEndian: Boolean = false,
    val bigEndian: Boolean = false,
    val others: Boolean = false,
) {
    LittleEndian(littleEndian = true),
    BigEndian(bigEndian = true),
    EitherEndian(bigEndian = true, littleEndian = true),
    Unknown(bigEndian = true, littleEndian = true, others = true);
}

/**
 * Stores encoding of one digit.
 */
data class Digit (
    val valueOrder: Order,
    val values: List<Char>,
)

/**
 * Target alphabets.
 */
enum class Alphabet(val chars: List<String>) {
    Standard(arrayListOf( "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z" )),
    BigPolishCross( arrayListOf("a", "b", "c", "d", "e", "f", "g", "h", "ch", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z" )),
    SmallPolishCross( arrayListOf("a", "b", "c", "d", "e", "f", "g", "h", "ch", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "x", "y", "z" )),
    QLess(arrayListOf( "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "r", "s", "t", "u", "v", "w", "x", "y", "z" )),
    WLess(arrayListOf( "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "x", "y", "z" )),
    BrailleCz( arrayListOf( "a", "?", "b", "?", "k", "i", "l", "?", "c", "j", "f", "i", "m", "s", "p", "?", "e", "?", "h", "?", "o", "?", "r", "?", "d", "0", "g", "e", "n", "t", "q", "?", "a", "?", "?", "?", "u", "?", "?", "v", "c", "o", "n", "?", "x", "?", "?", "?", "s", "?", "t", "z", "?", "w", "?", "d", "r", "ch", "#", "y",)),
    Semaphore1( SemaphoreGenerator.getSemaphore(1, 8)),
    Semaphore2( SemaphoreGenerator.getSemaphore(0, 9)),
}

/**
 * We assume that the cipher corresponds to some number-like coding, and hereby descibe what is known about this coding.
 * Later, this information will be used to produce decoder candidates.
 *
 * All inputs and intermediate data are stored as little-endian.
 */
data class Problem (
    val digitOrder: Order,
    val digits: List<Digit>,
    val alphabets: List<Alphabet>,
    val offsets: List<Int>,
    val code: List<CodeUnit>,
)

/**
 * Represents group of characters which encode one letter.
 */
typealias CodeUnit = List<Char>

/**
 * Decoder candidate, fully describing exactly one decoding mechanism. These are generated by combinatorial
 * expansion of the `Problem` class.
 */
data class Decoder(
    val priority: Int,
    val digitTable: List<Map<Char, Int>>,
    val code: List<CodeUnit>,
    val startOffset: Int,
    val alphabet: Alphabet,
) {
    fun describe(): String {
        val alphabet = alphabet.name
        val table = digitTable.reversed().map {
            val sortedDigits = it.toList()
                .sortedBy { it.second }
            val digits = sortedDigits
                .map { it.first }
                .filter { it != ' ' }
                .joinToString("")
            val magnitude = sortedDigits.getOrNull(1)?.second
                .let { "($it)"}

            digits + magnitude
        }.joinToString(" ")

        return "$table - $alphabet"
    }
}

/**
 * Single result candidate instance.
 */
data class Result(
    val rating: Double,
    val result: String,
    val decoder: Decoder,
) {
    fun describe(): String {
        val rating = rating.toString().let { it.substring(0, 8.coerceAtMost(it.length)) }
        val decoder = decoder.describe()

        return listOf(result, rating, decoder).joinToString (" - ")
    }
}

/**
 * In order to identify solution candidates, we compare frequency of characters and character pairs of a decoded text
 * with a precomputed probability profile.
 */
data class BackgroundProfile(
    val probabilities: List<FrequencyMap>,
) {
    data class FrequencyMap(
        val map: Map<String, Double>,
        val defaultRating: Double,
        val degree: Int,
    )

    companion object {
        val default = ProfileGenerator.generateProfileFromString(
            ProfileGenerator.SeedTexts.czech + ProfileGenerator.SeedTexts.english,
            degrees = listOf(3)
        )
    }
}